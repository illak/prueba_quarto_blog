---
title: "Generar mapas interactivos"
lang: es
author: "Zapata Illak"
date: "2022-09-17"
categories: [an√°lisis, R, c√≥digo, plotly, interactivo]
language: 
  title-block-author-single: "Autor"
  title-block-published: "Fecha"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

```{r librerias}
library(tidyverse)  # para flujo de trabajo con datos
library(sf)         # para trabajar con datos espaciales
library(lubridate)  # para trabajar con fechas
library(scales)     # para formatos varios
library(showtext)   # para cambiar las fuentes del texto
library(plotly)     # para mapas interactivos
```

Este post se basa en los datos introducidos [en este otro post](https://illak-blog.netlify.app/posts/analisis-salario-arg/){target="_blank"}. El objetivo ser√° generar un mapa interactivo con la librer√≠a `plotly`.

Vamos con la configuraci√≥n inicial.

```{r datos}
# salario promedio depto (total empresas)
salario_prom_depto <- read_csv("https://cdn.produccion.gob.ar/cdn-cep/datos-por-departamento/salarios/w_mean_depto_tot_emp.csv")

# diccionario deptos
dicc_deptos <- read_csv("https://cdn.produccion.gob.ar/cdn-cep/datos-por-departamento/diccionario_cod_depto.csv")

data_deptos_ARG <- read_sf("data/departamentos_arg.geojson")

```

```{r preparaci√≥n de datos}
# vamos a observar √∫nicamente el a√±o 2021
salarios_2021 <- salario_prom_depto %>% 
  # year es una funci√≥n de lubridate
  filter(year(fecha)==2021)


# filtramos los casos -99 y nos quedamos con el mes de diciembre
salarios_dic_2021 <- salarios_2021 %>% 
  filter(w_mean > 0, fecha == "2021-12-01")


caba_fix <- data_deptos_ARG %>%
  select(departamen, provincia, geometry, codigo_departamento_indec) %>%
  group_by(provincia) %>%
  filter(provincia == "Ciudad Aut√≥noma de Buenos Aires") %>%
  summarize(geometry = st_union(geometry),
            codigo_departamento_indec = "02000") %>%
  ungroup() %>% 
  mutate(geometry = st_combine(geometry))

sin_CABA <- filter(data_deptos_ARG, provincia != "Ciudad Aut√≥noma de Buenos Aires")

# el "nuevo" dataset pero con id 2000 para CABA
data_deptos_ARG <- sin_CABA %>%
  bind_rows(caba_fix) 
```

```{r salario x depto}
# corregimos el tipo 
data_deptos_ARG <- data_deptos_ARG %>% 
  mutate(codigo_departamento_indec = as.numeric(codigo_departamento_indec))

# agregamos la informaci√≥n de salarios para cada depto
deptos_salario_dic_2021 <- data_deptos_ARG %>% 
  left_join(salarios_dic_2021)

```

La visualizaci√≥n m√°s simple que podemos obtener de la distribuci√≥n de salarios promedios es la siguiente:

```{r gr√°fica - primer, fig.width= 6, fig.height = 10}

# graficamos
ggplot(deptos_salario_dic_2021) +
  geom_sf(aes(fill = w_mean)) +
  labs(fill = "Salario promedio") +
  # usamos la paleta de colores viridis cuya principal
  # caracter√≠stica es la accesibilidad
  scale_fill_viridis_c(option = "viridis") +
  theme_void() +
  theme(
    legend.text = element_text(size = 12),
    legend.title = element_text(size = 13)
  )

```

Como se puede observar en la leyenda, el salario promedio no muestra el punto separador de miles. Por otra parte podriamos detallar el tipo de unidad que estamos trabajando, es decir, el signo peso (\$). Nuestra tarea ser√° mejorar estos aspectos, para lo cual haremos uso de una libreria que fu√© pensada para trabajar con el reescalado de datos.

Pero... ¬øQu√© significa esto del "reescalado" de datos?.

::: callout-note
En el [post](https://illak-blog.netlify.app/posts/analisis-salario-arg/){target="_blank"} que introduce los datos utilizados y en donde realizamos un an√°lisis exploratorio de los mismos, no escrib√≠ sobre la utilidad de la libreria `scales`. A continuaci√≥n voy a desarrollar sobre el uso de esta librer√≠a, para un caso puntual.
:::

Puede ser que estemos trabajando con ciertos valores que est√©n en una determinada escala. Tomemos como ejemplo las proporciones. Supongamos que luego de nuestro an√°lisis hemos obtenido una tabla como la siguiente:

```{r}
tabla <- data.frame(
  tipo = c("T1","T2","T3"),
  n = c(200,100,100),
  pct = c(.5,.25,.25)
)

tabla
```

En la cual hemos calculado las proporciones con respecto al total (400) para cada tipo.

*"Del total de casos (400), 200 son de tipo T1, 100 de tipo T2 y 100 de tipo T3".*

Dicho de otra forma, el 50% de casos son de tipo T1, el 25% de tipo T2 y el 25% restante de tipo T3. Ahora bien, al momento de graficar estos datos, podr√≠amos hacer algo como esto:

```{r}
tabla %>% 
  ggplot(aes(x = tipo, y = pct)) +
  geom_col()
```

Pero si usamos estos valores, al lector le ser√° dificil interpretar que nuestro objetivo era mostrar porcentajes en el eje Y. En lugar de 0.5, lo ideal ser√≠a mostrar 50%. Lo mismo sucede con nuestro ejemplo principal de este post, es decir, los valores de salario promedio. No es lo mismo mostrar *350000* que *\$350.000* Al lector le ser√° m√°s f√°cil identificar la unidad con que se est√° trabajando y el separador de miles. Recordemos que nuestro objetivo ser√° que la visualizaci√≥n de datos no confunda, sino que debe facilitar la comprensi√≥n.

Luego de haber hecho esta breve y simple justificaci√≥n de la importancia del reescalado, veamos c√≥mo se usa la libreria `scales` para transformar escalas y adem√°s "mostrarlas" en nuestras gr√°ficas. Es tan sencillo como agregar lo siguiente:

```{r}
tabla %>% 
  ggplot(aes(x = tipo, y = pct)) +
  geom_col() +
  # modificamos la escala de Y indicando que
  # las etiquetas sean valores porcentuales
  scale_y_continuous(labels = scales::label_percent())
```

Ahora corrijamos nuestra leyenda del mapa haciendo uso de la funci√≥n de `label_dollar()` de `scales`.

```{r gr√°fica - segundo, fig.width= 6, fig.height = 10}


# graficamos
ggplot(deptos_salario_dic_2021) +
  geom_sf(aes(fill = w_mean)) +
  labs(fill = "Salario promedio") +
  # usamos la paleta de colores viridis cuya principal
  # caracter√≠stica es la accesibilidad
  # adem√°s, ahora modificamos las etiquetas
  scale_fill_viridis_c(option = "viridis",
                       labels = scales::label_dollar()) +
  theme_void() +
  theme(
    legend.text = element_text(size = 12),
    legend.title = element_text(size = 13)
  )
```

Perfecto! pero hay un detalle... nosotros separamos miles usando punto y no coma. Por defecto la funci√≥n usa la coma para separar miles. Vamos a hacer unos ajustes a la funci√≥n para modificar este comportamiento.

```{r gr√°fica - tercero, fig.width= 6, fig.height = 10}


# graficamos
ggplot(deptos_salario_dic_2021) +
  geom_sf(aes(fill = w_mean)) +
  labs(fill = "Salario promedio") +
  # usamos la paleta de colores viridis cuya principal
  # caracter√≠stica es la accesibilidad
  # adem√°s, ahora modificamos las etiquetas
  # y modificamos el comportamiento por defecto de
  # la funci√≥n indicando separadores de miles
  # y decimales
  scale_fill_viridis_c(option = "viridis",
                       labels = scales::label_dollar(
                         big.mark = ".",
                         decimal.mark = ","
                       )) +
  theme_void() +
  theme(
    legend.text = element_text(size = 12),
    legend.title = element_text(size = 13)
  )
```

# Agregando interactividad al mapa

Bien, volvamos a nuestro objetivo inicial... generar un mapa interactivo. Vamos a ver que generar un mapa de este tipo resulta demasiado sencillo. Y es que simplemente, a nuestro flujo de trabajo inicial, el que utilizamos para generar el mapa est√°tico, debemos sumarle la funci√≥n `ggplotly()` y listo! tenemos un mapa interactivo. A esta funci√≥n le pasamos el par√°metro `tooltip`, el cual indica qu√© *aesthetic* mostrar cu√°ndo pasemos el puntero por encima de las regiones del mapa. En nuestro caso vamos a mostrar un texto que combina el dato del nombre de la *provincia*, el *departamento* y el *salario promedio*.

```{r mapa interactivo, fig.width= 6, fig.height = 10}

etiquetadora <- scales::label_dollar(
                         big.mark = ".",
                         decimal.mark = ","
                       )

deptos_salario_dic_2021 <- deptos_salario_dic_2021 %>% 
  mutate(
    salario = etiquetadora(w_mean),
    tooltip = paste0(provincia,"\n",departamen,"\n",salario))

# graficamos
mapa_plot <- ggplot(deptos_salario_dic_2021, aes(text = tooltip)) +
  geom_sf(aes(fill = w_mean)) +
  labs(fill = "Salario promedio") +
  # usamos la paleta de colores viridis cuya principal
  # caracter√≠stica es la accesibilidad
  # adem√°s, ahora modificamos las etiquetas
  # y modificamos el comportamiento por defecto de
  # la funci√≥n indicando separadores de miles
  # y decimales
  scale_fill_viridis_c(option = "viridis",
                       labels = scales::label_dollar(
                         big.mark = ".",
                         decimal.mark = ","
                       )) +
  theme_void() +
  theme(
    legend.text = element_text(size = 12),
    legend.title = element_text(size = 13)
  )


# la "magia" de ggplotly üßô‚Äç‚ôÇÔ∏è
ggplotly(
  mapa_plot,
  tooltip = "text"
) %>% 
  style(
    hoveron = "fill"
  )
```

Un dato de inter√©s, es el uso de `style`, que nos permite agregar algunas propiedades visuales. En este caso usaremos la propiedad `hoveron`.

Esto es para evitar cierto comportamiento extra√±o al pasar el puntero por encima de un departamento. Te propongo visualizar tal comportamiento quitando la funci√≥n style.
